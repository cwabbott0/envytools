<?xml version="1.0" encoding="UTF-8"?>
<database xmlns="http://nouveau.freedesktop.org/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://nouveau.freedesktop.org/ rules-ng.xsd">

<!--
	This documents the internal register space used by the CP firmware since
	the afuc instruction set was introduced.
-->

<enum name="a5xx_config_reg">
	<value name="IB1_BASE_LO" value="0x0b0"/>
	<value name="IB1_BASE_HI" value="0x0b1"/>
	<value name="IB1_DWORDS" value="0x0b2"/>
	<value name="IB2_BASE_LO" value="0x0b4"/>
	<value name="IB2_BASE_HI" value="0x0b5"/>
	<value name="IB2_DWORDS" value="0x0b6"/>

	<doc>
		To use these, write the address and number of dwords, then read
		the result from $addr.
	</doc>
	<value name="MEM_READ_ADDR_LO" value="0x0b8"/>
	<value name="MEM_READ_ADDR_HI" value="0x0b9"/>
	<value name="MEM_READ_DWORDS" value="0x0ba"/>
</enum>

<enum name="a6xx_config_reg">
	<value name="RB_RPTR" value="0x001"/>
	<doc>
		Instruction to jump to when the CP is preempted to perform a
		context switch, initialized to entry 15 of the jump table at
		bootup.
	</doc>
	<value name="PREEMPT_INSTR" value="0x004"/>

	<value name="IB1_BASE_LO" value="0x010"/>
	<value name="IB1_BASE_HI" value="0x011"/>
	<value name="IB1_DWORDS" value="0x012"/>
	<value name="IB2_BASE_LO" value="0x014"/>
	<value name="IB2_BASE_HI" value="0x015"/>
	<value name="IB2_DWORDS" value="0x016"/>

	<value name="MEM_READ_ADDR_LO" value="0x018"/>
	<value name="MEM_READ_ADDR_HI" value="0x019"/>
	<value name="MEM_READ_DWORDS" value="0x01a"/>

	<value name="REG_WRITE_ADDR" value="0x024"/>
	<doc>
		Writing to this triggers a register write and auto-increments
		REG_WRITE_ADDR.
	</doc>
	<value name="REG_WRITE" value="0x025"/>

	<doc> After setting these, read result from $addr2 </doc>
	<value name="REG_READ_DWORDS" value="0x026"/>
	<value name="REG_READ_ADDR" value="0x027"/>

	<value name="DRAW_STATE_SEL" value="0x041"/>
	<value name="DRAW_STATE_ACTIVE_BITMASK" value="0x049"/>
	<value name="DRAW_STATE_SET" value="0x04a"/>

	<doc> Controls whether RB, IB1, or IB2 is executed </doc>
	<value name="IB_LEVEL" value="0x054"/>

	<doc> Controls high 32 bits used by load and store afuc instructions </doc>
	<value name="LOAD_STORE_HI" value="0x058"/>

	<doc> Used to initialize the jump table for handling packets at bootup </doc>
	<value name="PACKET_TABLE_WRITE_ADDR" value="0x060"/>
	<value name="PACKET_TABLE_WRITE" value="0x061"/>

	<value name="PREEMPT_ENABLE" value="0x071"/>
	<value name="SECURE_MODE" value="0x075"/>

	<!--
		Note: I think that registers above 0x100 are actually just a
		scratch space which can be used by firmware however it wants,
		so these might change if the the firmware is updated.
        -->

	<doc>
		These are addresses of various preemption records for the
		current context. When context switching, the CP will save the
		current state into these buffers, restore the state of the
		next context from the buffers in the corresponding
		CP_CONTEXT_SWITCH_PRIV_* registers written by the kernel,
		then set these internal registers to the contents of
		those registers. The kernel sets the initial values via
		CP_SET_PSEUDO_REG on startup, and from then on the firmware
		keeps track of them.
	</doc>
	<value name="SAVE_REGISTER_SMMU_INFO_LO" value="0x110"/>
	<value name="SAVE_REGISTER_SMMU_INFO_HI" value="0x111"/>
	<value name="SAVE_REGISTER_PRIV_NON_SECURE_LO" value="0x112"/>
	<value name="SAVE_REGISTER_PRIV_NON_SECURE_HI" value="0x113"/>
	<value name="SAVE_REGISTER_PRIV_SECURE_LO" value="0x114"/>
	<value name="SAVE_REGISTER_PRIV_SECURE_HI" value="0x115"/>
	<value name="SAVE_REGISTER_NON_PRIV_LO" value="0x116"/>
	<value name="SAVE_REGISTER_NON_PRIV_HI" value="0x117"/>
	<value name="SAVE_REGISTER_COUNTER_LO" value="0x118"/>
	<value name="SAVE_REGISTER_COUNTER_HI" value="0x119"/>

	<doc>
		Used only during preemption, saved and restored from the "info"
		field of a6xx_preemption_record. From the downstream kernel:

		"Type of record. Written non-zero (usually) by CP.
		we must set to zero for all ringbuffers."
	</doc>

	<value name="PREEMPTION_INFO" value="0x126"/>

	<doc>
		Set by SET_MARKER, used to conditionally execute
		CP_COND_REG_EXEC and draw states.
	</doc>
	<value name="MODE_BITMASK" value="0x12b"/>

	<value name="SCRATCH_REG0" value="0x170"/>
	<value name="SCRATCH_REG1" value="0x171"/>
	<value name="SCRATCH_REG2" value="0x172"/>
	<value name="SCRATCH_REG3" value="0x173"/>
	<value name="SCRATCH_REG4" value="0x174"/>
	<value name="SCRATCH_REG5" value="0x175"/>
	<value name="SCRATCH_REG6" value="0x176"/>
	<value name="SCRATCH_REG7" value="0x177"/>
</enum>

</database>
